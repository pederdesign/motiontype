<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jockey</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #f9b4c8;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    font-family: monospace;
    transition: background 0.5s ease;
  }

  .corner {
    position: fixed;
    font-size: 11px;
    letter-spacing: 0.15em;
    color: #1a2b2b;
    font-weight: 600;
    text-transform: uppercase;
    transition: color 0.4s;
    z-index: 10;
  }
  .corner.tl { top: 28px; left: 32px; }
  .corner.tr { top: 28px; right: 32px; }
  .corner.bl { bottom: 28px; left: 32px; }
  .corner.br { bottom: 28px; right: 32px; }

  .mode-label {
    position: fixed;
    top: 28px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 10px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #1a2b2b;
    opacity: 0.4;
    font-weight: 700;
    font-family: monospace;
    transition: color 0.4s;
    z-index: 10;
  }

  .switcher {
    position: fixed;
    bottom: 52px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    background: rgba(26,43,43,0.1);
    padding: 5px;
    border-radius: 999px;
    z-index: 10;
  }

  .mode-btn {
    font-family: monospace;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    padding: 7px 16px;
    border: none;
    border-radius: 999px;
    cursor: pointer;
    background: transparent;
    color: #1a2b2b;
    opacity: 0.45;
    transition: opacity 0.2s, background 0.2s, color 0.2s;
  }
  .mode-btn.active {
    background: #1a2b2b;
    color: #f9b4c8;
    opacity: 1;
  }

  .word {
    display: flex;
    align-items: center;
    position: relative;
    z-index: 2;
  }

  .letter-wrap {
    display: flex;
    align-items: center;
    flex-shrink: 0;
    cursor: pointer;
    transform-origin: center center;
    will-change: transform;
  }

  .letter-wrap svg {
    display: block;
    height: clamp(80px, 14vw, 200px);
    width: auto;
    overflow: visible;
    pointer-events: none;
    transition: opacity 0.15s ease;
  }

  #dust-canvas {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 3;
    display: none;
  }
</style>
</head>
<body>

<span class="corner tl">20</span>
<span class="corner tr">BFF</span>
<span class="corner bl">BFF</span>
<span class="corner br">20</span>
<span class="mode-label" id="modeLabel">Rubber Band</span>

<canvas id="dust-canvas"></canvas>

<div class="word" id="word">

  <!-- J -->
  <div class="letter-wrap" data-index="0">
    <svg viewBox="0 0 241 220" xmlns="http://www.w3.org/2000/svg">
      <defs><clipPath id="ink-clip-0"><rect class="ink-rect" x="-5" y="220" width="251" height="460"/></clipPath></defs>
      <path class="base-path" d="M240.91,163.32c0,11.21-2.34,21.01-7,29.41-4.67,8.4-11.21,14.94-19.61,19.61-8.4,4.67-18.21,7-29.41,7H56.03c-11.21,0-21.01-2.34-29.41-7-8.4-4.67-14.94-11.21-19.61-19.61-4.67-8.4-7-18.21-7-29.41v-50.98h78.16v27.73c0,2.43.79,4.44,2.38,6.02,1.58,1.59,3.59,2.38,6.02,2.38,1.68,0,3.17-.37,4.48-1.12,1.3-.74,2.29-1.72,2.94-2.94.65-1.21.98-2.66.98-4.34v-69.19H0V0h240.91v163.32Z"/>
      <path class="flood-path" clip-path="url(#ink-clip-0)" d="M240.91,163.32c0,11.21-2.34,21.01-7,29.41-4.67,8.4-11.21,14.94-19.61,19.61-8.4,4.67-18.21,7-29.41,7H56.03c-11.21,0-21.01-2.34-29.41-7-8.4-4.67-14.94-11.21-19.61-19.61-4.67-8.4-7-18.21-7-29.41v-50.98h78.16v27.73c0,2.43.79,4.44,2.38,6.02,1.58,1.59,3.59,2.38,6.02,2.38,1.68,0,3.17-.37,4.48-1.12,1.3-.74,2.29-1.72,2.94-2.94.65-1.21.98-2.66.98-4.34v-69.19H0V0h240.91v163.32Z"/>
    </svg>
  </div>

  <!-- O -->
  <div class="letter-wrap" data-index="1">
    <svg viewBox="0 0 355 220" xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(-308,0)">
        <defs><clipPath id="ink-clip-1"><rect class="ink-rect" x="258" y="220" width="415" height="460"/></clipPath></defs>
        <path class="base-path" d="M475.79,0c48.85,0,87.43,4.11,115.72,12.33,28.3,8.22,48.72,20.45,61.31,36.7,6.77,8.03,11.48,17.14,14.15,27.31,2.65,10.18,3.99,21.34,3.99,33.48,0,8.96-.73,17.42-2.18,25.35-1.45,7.94-4.12,15.36-7.98,22.27-5.33,11.39-13.67,21.2-25.03,29.41-11.37,8.22-26.01,14.94-43.89,20.17-14.51,4.11-31.45,7.19-50.79,9.24-19.35,2.05-41.12,3.08-65.3,3.08h-23.22c-23.7,0-44.98-.98-63.85-2.94-18.87-1.96-35.55-5-50.06-9.1-17.9-5.23-32.65-11.95-44.26-20.17-11.61-8.22-20.56-18.02-26.85-29.41-3.39-6.91-5.93-14.38-7.62-22.41-1.7-8.03-2.54-16.62-2.54-25.77s.73-17.69,2.18-25.63c1.45-7.94,3.87-15.36,7.26-22.27,5.32-11.58,13.54-21.43,24.67-29.55,11.12-8.12,25.63-14.8,43.53-20.03,14.51-4.11,31.44-7.14,50.79-9.1,19.34-1.96,41.59-2.94,66.75-2.94h23.22ZM298.75,123.26c2.9,3.92,8.22,7.19,15.96,9.8,5.8,1.68,13.42,2.99,22.85,3.92,9.43.94,20.92,1.4,34.46,1.4h184.29c5.32,0,10.27-.09,14.87-.28,4.59-.18,8.82-.37,12.7-.56,8.22-.56,15.24-1.4,21.04-2.52,5.8-1.12,10.63-2.42,14.51-3.92,5.32-2.61,9.07-5.65,11.25-9.1,2.18-3.45,3.26-7.51,3.26-12.19,0-5.41-1.34-10.08-3.99-14.01-2.66-3.92-8.11-7.1-16.32-9.53-5.8-1.68-13.31-2.98-22.49-3.92-9.19-.93-20.8-1.4-34.82-1.4h-184.29c-10.65,0-19.95.28-27.93.84s-14.87,1.4-20.68,2.52c-11.61,2.06-19.35,5.23-23.22,9.53-3.88,4.3-5.8,9.52-5.8,15.69,0,5.23,1.45,9.8,4.35,13.73Z"/>
        <path class="flood-path" clip-path="url(#ink-clip-1)" d="M475.79,0c48.85,0,87.43,4.11,115.72,12.33,28.3,8.22,48.72,20.45,61.31,36.7,6.77,8.03,11.48,17.14,14.15,27.31,2.65,10.18,3.99,21.34,3.99,33.48,0,8.96-.73,17.42-2.18,25.35-1.45,7.94-4.12,15.36-7.98,22.27-5.33,11.39-13.67,21.2-25.03,29.41-11.37,8.22-26.01,14.94-43.89,20.17-14.51,4.11-31.45,7.19-50.79,9.24-19.35,2.05-41.12,3.08-65.3,3.08h-23.22c-23.7,0-44.98-.98-63.85-2.94-18.87-1.96-35.55-5-50.06-9.1-17.9-5.23-32.65-11.95-44.26-20.17-11.61-8.22-20.56-18.02-26.85-29.41-3.39-6.91-5.93-14.38-7.62-22.41-1.7-8.03-2.54-16.62-2.54-25.77s.73-17.69,2.18-25.63c1.45-7.94,3.87-15.36,7.26-22.27,5.32-11.58,13.54-21.43,24.67-29.55,11.12-8.12,25.63-14.8,43.53-20.03,14.51-4.11,31.44-7.14,50.79-9.1,19.34-1.96,41.59-2.94,66.75-2.94h23.22ZM298.75,123.26c2.9,3.92,8.22,7.19,15.96,9.8,5.8,1.68,13.42,2.99,22.85,3.92,9.43.94,20.92,1.4,34.46,1.4h184.29c5.32,0,10.27-.09,14.87-.28,4.59-.18,8.82-.37,12.7-.56,8.22-.56,15.24-1.4,21.04-2.52,5.8-1.12,10.63-2.42,14.51-3.92,5.32-2.61,9.07-5.65,11.25-9.1,2.18-3.45,3.26-7.51,3.26-12.19,0-5.41-1.34-10.08-3.99-14.01-2.66-3.92-8.11-7.1-16.32-9.53-5.8-1.68-13.31-2.98-22.49-3.92-9.19-.93-20.8-1.4-34.82-1.4h-184.29c-10.65,0-19.95.28-27.93.84s-14.87,1.4-20.68,2.52c-11.61,2.06-19.35,5.23-23.22,9.53-3.88,4.3-5.8,9.52-5.8,15.69,0,5.23,1.45,9.8,4.35,13.73Z"/>
      </g>
    </svg>
  </div>

  <!-- C -->
  <div class="letter-wrap" data-index="2">
    <svg viewBox="0 0 226 220" xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(-629,0)">
        <defs><clipPath id="ink-clip-2"><rect class="ink-rect" x="624" y="220" width="240" height="460"/></clipPath></defs>
        <path class="base-path" d="M767.55,0h76.76v80.96h-114.01c-12.33,0-20.41,2.43-24.23,7.28-3.83,4.86-5.74,11.95-5.74,21.29s1.91,16.48,5.74,21.43c3.82,4.95,11.9,7.42,24.23,7.42h114.01v80.96h-76.76c-20.17,0-36.19-3.97-48.04-11.91-11.86-7.94-20.41-20.03-25.63-36.28-5.23-16.25-7.84-36.79-7.84-61.63s2.61-45.33,7.84-61.49c5.22-16.15,13.77-28.2,25.63-36.14,11.86-7.94,27.87-11.91,48.04-11.91Z"/>
        <path class="flood-path" clip-path="url(#ink-clip-2)" d="M767.55,0h76.76v80.96h-114.01c-12.33,0-20.41,2.43-24.23,7.28-3.83,4.86-5.74,11.95-5.74,21.29s1.91,16.48,5.74,21.43c3.82,4.95,11.9,7.42,24.23,7.42h114.01v80.96h-76.76c-20.17,0-36.19-3.97-48.04-11.91-11.86-7.94-20.41-20.03-25.63-36.28-5.23-16.25-7.84-36.79-7.84-61.63s2.61-45.33,7.84-61.49c5.22-16.15,13.77-28.2,25.63-36.14,11.86-7.94,27.87-11.91,48.04-11.91Z"/>
      </g>
    </svg>
  </div>

  <!-- K -->
  <div class="letter-wrap" data-index="3">
    <svg viewBox="0 0 253 220" xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(-844,0)">
        <defs><clipPath id="ink-clip-3"><rect class="ink-rect" x="839" y="220" width="268" height="460"/></clipPath></defs>
        <path class="base-path" d="M855.51,219.34V0h140.06v97.21L1077.93,0h18.49l-92.44,109.53,92.44,109.81h-18.49l-82.36-97.49v97.49h-140.06Z"/>
        <path class="flood-path" clip-path="url(#ink-clip-3)" d="M855.51,219.34V0h140.06v97.21L1077.93,0h18.49l-92.44,109.53,92.44,109.81h-18.49l-82.36-97.49v97.49h-140.06Z"/>
      </g>
    </svg>
  </div>

  <!-- E -->
  <div class="letter-wrap" data-index="4">
    <svg viewBox="0 0 242 220" xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(-1107,0)">
        <defs><clipPath id="ink-clip-4"><rect class="ink-rect" x="1102" y="220" width="257" height="460"/></clipPath></defs>
        <path class="base-path" d="M1348.54,80.4v61.07h-129.14v13.45h129.14v64.43h-240.91V0h240.91v66.95h-129.14v13.45h129.14Z"/>
        <path class="flood-path" clip-path="url(#ink-clip-4)" d="M1348.54,80.4v61.07h-129.14v13.45h129.14v64.43h-240.91V0h240.91v66.95h-129.14v13.45h129.14Z"/>
      </g>
    </svg>
  </div>

  <!-- Y -->
  <div class="letter-wrap" data-index="5">
    <svg viewBox="0 0 244 220" xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(-1358,0)">
        <defs><clipPath id="ink-clip-5"><rect class="ink-rect" x="1353" y="220" width="259" height="460"/></clipPath></defs>
        <path class="base-path" d="M1358.34,0h106.17l15.41,36.98,15.97-36.98h106.17l-42.02,110.09v109.25h-155.75v-109.25L1358.34,0Z"/>
        <path class="flood-path" clip-path="url(#ink-clip-5)" d="M1358.34,0h106.17l15.41,36.98,15.97-36.98h106.17l-42.02,110.09v109.25h-155.75v-109.25L1358.34,0Z"/>
      </g>
    </svg>
  </div>

</div>

<div class="switcher">
  <button class="mode-btn active" data-mode="rubber">Rubber Band</button>
  <button class="mode-btn" data-mode="ink">Ink Bleed</button>
  <button class="mode-btn" data-mode="glitch">Scramble</button>
  <button class="mode-btn" data-mode="dust">Explode</button>
</div>

<script>
  const GAP = 18;
  const word = document.getElementById('word');
  const letters = Array.from(word.querySelectorAll('.letter-wrap'));
  const modeLabel = document.getElementById('modeLabel');
  const dustCanvas = document.getElementById('dust-canvas');
  const ctx = dustCanvas.getContext('2d');

  let currentMode = 'rubber';

  const inkColors   = ['#e63946','#f4a261','#2a9d8f','#e9c46a','#5e60ce','#e76f51'];
  const bgColors    = { rubber: '#f9b4c8', ink: '#f0e8d8', glitch: '#0e0e0e', dust: '#f0ede8' };
  const modeNames   = { rubber: 'Rubber Band', ink: 'Ink Bleed', glitch: 'Scramble / Glitch', dust: 'Explode' };
  const transitions = {
    rubber: 'transform 0.55s cubic-bezier(0.34, 1.7, 0.64, 1)',
    ink:    'transform 0.25s ease',
    glitch: 'none',
    dust:   'transform 0.3s ease',
  };

  letters.forEach((el, i) => { if (i > 0) el.style.marginLeft = GAP + 'px'; });

  // ─────────────────────────────────────────
  // INK BLEED
  // ─────────────────────────────────────────
  const inkState = letters.map(() => ({ y: 220, target: 220, raf: null }));

  function animateInkClip(idx, toY) {
    const state = inkState[idx];
    state.target = toY;
    if (state.raf) cancelAnimationFrame(state.raf);
    function step() {
      state.y += (state.target - state.y) * 0.13;
      const rect = document.querySelector(`#ink-clip-${idx} .ink-rect`);
      if (rect) rect.setAttribute('y', state.y);
      if (Math.abs(state.y - state.target) > 0.3) {
        state.raf = requestAnimationFrame(step);
      } else {
        state.y = state.target;
        if (rect) rect.setAttribute('y', state.y);
        state.raf = null;
      }
    }
    state.raf = requestAnimationFrame(step);
  }

  // ─────────────────────────────────────────
  // PUSH NEIGHBORS helper
  // ─────────────────────────────────────────
  function pushNeighbors(hoveredIdx, scaleX) {
    const w = letters[hoveredIdx].getBoundingClientRect().width;
    const extra = (w * scaleX - w) / 2;
    letters.forEach((el, i) => {
      if (i !== hoveredIdx) {
        const dir = i > hoveredIdx ? 1 : -1;
        el.style.transform = `translateX(${dir * extra}px)`;
      }
    });
  }

  function resetAll() {
    letters.forEach((el, i) => {
      el.style.transform = '';
      el.querySelector('svg').style.opacity = '1';
      if (currentMode === 'ink') animateInkClip(i, 220);
    });
  }

  // ─────────────────────────────────────────
  // RUBBER BAND
  // ─────────────────────────────────────────
  function rubberEnter(idx) {
    const SCALE = 2.0;
    letters[idx].style.transform = `scaleX(${SCALE})`;
    pushNeighbors(idx, SCALE);
  }

  // ─────────────────────────────────────────
  // INK BLEED
  // ─────────────────────────────────────────
  function inkEnter(idx) { animateInkClip(idx, -30); }
  function inkLeave(idx) { animateInkClip(idx, 220); }

  // ─────────────────────────────────────────
  // GLITCH / SCRAMBLE
  // ─────────────────────────────────────────
  const glitchColors = ['#ff003c','#00ffe7','#ffe600','#ff6af8','#39ff14','#ff6600'];
  let glitchRAFs = {};

  function rand(min, max) { return Math.random() * (max - min) + min; }

  function scrambleLetter(el, idx, intensity, duration) {
    const base  = el.querySelector('.base-path');
    const start = performance.now();
    function tick(now) {
      const elapsed = now - start;
      if (elapsed >= duration) {
        el.style.transform = '';
        el.style.transition = 'transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1)';
        if (base) base.style.fill = '#f9b4c8';
        return;
      }
      const decay = 1 - elapsed / duration;
      el.style.transition = 'none';
      el.style.transform = `translate(${rand(-intensity,intensity)*decay}px,${rand(-intensity*.6,intensity*.6)*decay}px) skewX(${rand(-8,8)*decay}deg) scaleX(${1+rand(-0.12,0.12)*decay})`;
      if (base && idx !== null && Math.random() > 0.4)
        base.style.fill = glitchColors[Math.floor(Math.random() * glitchColors.length)];
      glitchRAFs[idx ?? `n${Math.random()}`] = requestAnimationFrame(tick);
    }
    glitchRAFs[idx ?? 'n'] = requestAnimationFrame(tick);
  }

  function glitchEnter(idx) {
    Object.values(glitchRAFs).forEach(cancelAnimationFrame);
    glitchRAFs = {};
    scrambleLetter(letters[idx], idx, 28, 520);
    letters.forEach((el, i) => {
      if (i === idx) return;
      const dist = Math.abs(i - idx);
      scrambleLetter(el, null, Math.max(4, 18 - dist*5), Math.max(180, 400 - dist*60));
    });
  }

  function glitchLeave() {
    Object.values(glitchRAFs).forEach(cancelAnimationFrame);
    glitchRAFs = {};
    letters.forEach(el => {
      el.style.transition = 'transform 0.3s cubic-bezier(0.34,1.56,0.64,1)';
      el.style.transform = '';
      el.querySelector('.base-path').style.fill = '#f9b4c8';
    });
  }

  // ─────────────────────────────────────────
  // EXPLODE + REASSEMBLE PARTICLES
  // ─────────────────────────────────────────
  let dustRAF = null;
  let particlesByLetter = {};
  let dustActive = new Set();

  let mouse = { x: 0, y: 0 };
  let smoothMouse = { x: 0, y: 0 };

  window.addEventListener('mousemove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  function resizeCanvas() {
    dustCanvas.width  = window.innerWidth;
    dustCanvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  function samplePathPoints(pathEl, svgEl, count) {
    const totalLen = pathEl.getTotalLength();
    const svgRect  = svgEl.getBoundingClientRect();
    const vb       = svgEl.viewBox.baseVal;
    const scaleX   = svgRect.width  / vb.width;
    const scaleY   = svgRect.height / vb.height;
    const g        = svgEl.querySelector('g[transform]');
    let offsetX    = 0;
    if (g) { const m = g.transform.baseVal[0]; if (m) offsetX = m.matrix.e; }

    const points = [];
    for (let i = 0; i < count; i++) {
      const pt  = pathEl.getPointAtLength((i / count) * totalLen);
      const vbX = pt.x + offsetX;
      points.push({
        x: svgRect.left + vbX * scaleX,
        y: svgRect.top  + pt.y * scaleY,
      });
    }
    return points;
  }

  // Dark particle palette for light background
  const particlePalette = [
    [26,  43,  43],
    [50,  70,  70],
    [15,  15,  20],
    [70,  40,  55],
    [35,  55,  50],
  ];

  function spawnParticles(idx) {
    const el     = letters[idx];
    const svgEl  = el.querySelector('svg');
    const pathEl = svgEl.querySelector('.base-path');
    if (!pathEl) return;

    const points = samplePathPoints(pathEl, svgEl, 480);
    const rect = el.getBoundingClientRect();
    const cx   = rect.left + rect.width  / 2;
    const cy   = rect.top  + rect.height / 2;

    particlesByLetter[idx] = points.map(pt => {
      const dx     = pt.x - cx;
      const dy     = pt.y - cy;
      const dist   = Math.sqrt(dx*dx + dy*dy) || 1;
      const speed  = rand(2.5, 9);
      const [r,g,b] = particlePalette[Math.floor(Math.random() * particlePalette.length)];
      return {
        x: pt.x, y: pt.y,
        ox: pt.x, oy: pt.y,
        vx: (dx / dist) * speed + rand(-1, 1),
        vy: (dy / dist) * speed + rand(-1, 1),
        state: 'exploding',
        size:  rand(1.5, 3.5),
        alpha: 1,
        r, g, b,
        wobble: rand(0, Math.PI * 2),
        drag: rand(0.91, 0.96),
        z: Math.random(),
      };
    });

    svgEl.style.transition = 'none';
    svgEl.style.opacity = '0';
  }

  function startReturn(idx) {
    if (!particlesByLetter[idx]) return;
    for (const p of particlesByLetter[idx]) {
      p.state = 'returning';
      p.vx = 0;
      p.vy = 0;
    }
  }

  function tickDust() {
    smoothMouse.x += (mouse.x - smoothMouse.x) * 0.08;
    smoothMouse.y += (mouse.y - smoothMouse.y) * 0.08;

    ctx.clearRect(0, 0, dustCanvas.width, dustCanvas.height);

    let anyAlive = false;

    for (const [idxStr, particles] of Object.entries(particlesByLetter)) {
      const idx = +idxStr;
      let allHome = true;

      for (const p of particles) {
        if (p.state === 'exploding') {
          allHome = false;
          p.vx *= p.drag;
          p.vy *= p.drag;
          p.x  += p.vx;
          p.y  += p.vy;
          if (Math.abs(p.vx) < 0.3 && Math.abs(p.vy) < 0.3) {
            p.state = 'floating';
            p.vx = rand(-0.25, 0.25);
            p.vy = rand(-0.4, -0.1);
          }
        } else if (p.state === 'floating') {
          allHome = false;
          p.wobble += 0.03;
          p.x += p.vx + Math.sin(p.wobble) * 0.2;
          p.y += p.vy;

          if (dustActive.has(idx)) {
            const dx = smoothMouse.x - p.x;
            const dy = smoothMouse.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 200) {
              const depthStrength = 0.015 + p.z * 0.035;
              const falloff = 1 - dist / 200;
              const influence = falloff * falloff;
              p.x += dx * depthStrength * influence;
              p.y += dy * depthStrength * influence;
            }
          }
        } else if (p.state === 'returning') {
          const dx = p.ox - p.x;
          const dy = p.oy - p.y;
          p.vx += dx * 0.12;
          p.vy += dy * 0.12;
          p.vx *= 0.75;
          p.vy *= 0.75;
          p.x  += p.vx;
          p.y  += p.vy;
          const d = Math.sqrt(dx*dx + dy*dy);
          if (d < 1.5) { p.x = p.ox; p.y = p.oy; }
          else allHome = false;
        }

        ctx.beginPath();
        const depthScale = 0.7 + p.z * 0.6;
        ctx.arc(p.x, p.y, p.size * depthScale, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${0.45 + p.z * 0.55})`;
        ctx.fill();
      }

      const allReturning = particles.every(p => p.state === 'returning');
      if (allReturning && allHome) {
        const el = letters[idx];
        if (el) {
          el.querySelector('svg').style.transition = 'opacity 0.35s ease';
          el.querySelector('svg').style.opacity = '1';
        }
        delete particlesByLetter[idx];
      } else {
        anyAlive = true;
      }
    }

    if (anyAlive || dustActive.size > 0) {
      dustRAF = requestAnimationFrame(tickDust);
    } else {
      dustRAF = null;
      ctx.clearRect(0, 0, dustCanvas.width, dustCanvas.height);
    }
  }

  function startDustLoop() {
    if (!dustRAF) dustRAF = requestAnimationFrame(tickDust);
  }

  function dustEnter(idx) {
    if (dustActive.has(idx)) return;
    dustActive.add(idx);
    spawnParticles(idx);
    startDustLoop();
  }

  function dustLeave(idx) {
    dustActive.delete(idx);
    startReturn(idx);
  }

  function clearAllDust() {
    dustActive.clear();
    particlesByLetter = {};
    if (dustRAF) { cancelAnimationFrame(dustRAF); dustRAF = null; }
    ctx.clearRect(0, 0, dustCanvas.width, dustCanvas.height);
    letters.forEach(el => {
      el.querySelector('svg').style.transition = 'none';
      el.querySelector('svg').style.opacity = '1';
    });
  }

  // ─────────────────────────────────────────
  // EVENT WIRING
  // ─────────────────────────────────────────
  letters.forEach((el, i) => {
    el.addEventListener('mouseenter', () => {
      if      (currentMode === 'rubber') rubberEnter(i);
      else if (currentMode === 'ink')    inkEnter(i);
      else if (currentMode === 'glitch') glitchEnter(i);
      else if (currentMode === 'dust')   dustEnter(i);
    });
    el.addEventListener('mouseleave', () => {
      if      (currentMode === 'ink')    inkLeave(i);
      else if (currentMode === 'glitch') glitchLeave();
      else if (currentMode === 'dust')   dustLeave(i);
      else resetAll();
    });
  });

  // ─────────────────────────────────────────
  // MODE VISUALS
  // ─────────────────────────────────────────
  function applyModeVisuals(mode) {
    clearAllDust();
    Object.values(glitchRAFs).forEach(cancelAnimationFrame);
    glitchRAFs = {};

    letters.forEach((el, i) => {
      el.style.transition = transitions[mode] === 'none' ? 'none' : transitions[mode];
      el.style.transform  = '';
      el.querySelector('svg').style.opacity = '1';
      const base  = el.querySelector('.base-path');
      const flood = el.querySelector('.flood-path');

      if (mode === 'ink') {
        if (base)  base.style.fill  = 'rgba(26,43,43,0.15)';
        if (flood) flood.style.fill = inkColors[i];
        animateInkClip(i, 220);
      } else if (mode === 'glitch') {
        if (base)  base.style.fill  = '#f9b4c8';
        if (flood) flood.style.fill = 'transparent';
      } else if (mode === 'dust') {
        if (base)  base.style.fill  = '#1a2b2b';
        if (flood) flood.style.fill = 'transparent';
      } else {
        if (base)  base.style.fill  = '#1a2b2b';
        if (flood) flood.style.fill = 'transparent';
      }
    });

    dustCanvas.style.display = mode === 'dust' ? 'block' : 'none';
    document.body.style.background = bgColors[mode];

    const lightModes = ['rubber', 'ink', 'dust'];
    const textColor = lightModes.includes(mode) ? '#1a2b2b' : 'rgba(249,180,200,0.55)';
    document.querySelectorAll('.corner, .mode-label').forEach(el => el.style.color = textColor);
    modeLabel.textContent = modeNames[mode];
  }

  // ─────────────────────────────────────────
  // MODE SWITCHER
  // ─────────────────────────────────────────
  document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      if (btn.dataset.mode === currentMode) return;
      resetAll();
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentMode = btn.dataset.mode;
      applyModeVisuals(currentMode);
    });
  });

  // ── Init ──
  applyModeVisuals('rubber');
</script>
</body>
</html>